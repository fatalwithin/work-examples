```diff
Задача - выбор типа поля в качестве первичного ключа для дизайна БД (СУБД = PostgreSQL)

По своей сути оба типа поля - UUID и Autoincrement INT являются суррогатными ключами и плюсы суррогатных ключей характерны для обоих типов. Далее будут рассмотрены плюсы и минусы, не относящиеся к теме "суррогатные ключи vs естественные ключи" 

1) UUID 
+ ПЛЮСЫ:
+ поле является стандартом независимо от типа БД и описано в RFC 4122, ISO/IEC 9834-8:2005 
+ в большинстве юз-кейсов нужен, либо очень желателен, глобально уникальный ключ, и UUID этому удовлетворяет
+ копирование, слияние и другие операции с разными базами/версиями баз не принесут проблем с дублированием ключей
+ позволяет легко генерировать данные одновременно в разных базах, в разных контурах, на разных серверах без боязни создать конфликты
+ использование UUID более безопасно и менее подвержено эксплойтам, т.к. при запросах данные скрыты за UUID
+ при разработке или дебаге операций PUT можно не бояться за случайное дублирование данных
+ нет проблем с шардированием базы - после шардирования или секционирования поле ключа все равно останется глобально уникальным
+ подходят для распределенных систем


- МИНУСЫ:
- занимают больше места, может быть критично в случае жесткой экономии ресурсов
- трудней дебажить (URL ссылающиеся на UUID - трудночитаемые, например)
- индексы таблиц с такими PK растут и перестраиваются очень быстро => больше нагрузки на CPU, память и диск
- если в таблице уже есть заведомо уникальное поле (по бизнес-логике), по которому можно безболезненно построить первичный ключ, то нужно все равно создавать новое поле с UUID
- UUID все же не гарантируют отсутствие коллизий (т.е. нарушения глобальной уникальности), особенно на очень больших кол-вах строк в БД
- могут быть проблемы с производительностью, если движок БД обрабатывает поля UUID как обычные строки (к PostgreSQL не относится)
- в том же PosgreSQL нужно заранее выбирать модуль и алгоритм для генерации полей с UUID, так как не каждый алгоритм подойдет для любой задачи (например uuid-ossp, pgcrypto) - либо генерировать UUID снаружи, из приложения

2) Autoincrement INT 
+ ПЛЮСЫ:
+ очень хорошо подходит под ряд задач, например под задачу генерации сокращенных URL 
+ проще создавать и проще работать с точки зрения кода
+ индексы по этим полям быстрые и занимают меньше места
+ хорошо подходит для баз одного инстанса (не распределенных) с одним мастером схемы

- МИНУСЫ:
- плохо подходят для больших баз с большим количеством сложносвязанных таблиц
- плохо подходят для таблиц, которые доступны для выборки из Интернета - уязвимо для эксплойтов и атак методом перебора
- плохо подходят для распределенных, секционированных и шардированных баз
- не подходят для данных, требующих глобальной уникальности 
- чтобы получить профит в производительности индексов - нужно либо очень большое приложение с большой базой (т.е. реальный хайлоад), либо работа в условиях очень слабого железа и жесткой экономии ресурсов 

3) Совмещенный подход: Autoincrement INT в качестве PK и UUID в качестве отдельного уникального поля в таблице
+ ПЛЮСЫ:
+ подходит для таблиц с публичной выборкой - нет проблем с безопасностью, можно использовать UUID
+ подходит для задач, где нужны быстрые индексы по первичным ключам и критична производительность

- МИНУСЫ:
- эти поля суммарно занимают очень много места и очень большой процент от полезных данных
- нужны строгие стандарты разработки
- потенциально еще сложней дебажить, чем таблицы только с UUID

ВЫВОДЫ:
    - если приложение, использующее СУБД большое, распределенное либо потенциально будет большим, серьезным или будет частью такового, будут задействованы внешние запросы из Интернета - лучше сразу заложиться на UUID и примириться с увеличением сложности на разработку, дебаг и поддержку
    - если приложение небольшое, локальное, не будет шардироваться и распределяться, запускается в среде с ограниченными ресурсами - использовать автоинкременты 

```